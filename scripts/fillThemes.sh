#!/bin/bash

# Generated by our good friend Chat Jippity
# Might be inefficient but it works

# Define directories and theme files
THEMES_DIR="$(dirname "$(realpath "$0")")/../themes"
COMPLETE_THEME_FILE="catppuccin_mocha.json"
COMPLETE_SPLIT_THEME_FILE="catppuccin_mocha_split.json"

# Check if jq is installed
if ! command -v jq &>/dev/null; then
    echo "jq is required but not installed. Please install jq and try again."
    exit 1
fi

# Function to fill missing values
fill_missing_values() {
    local complete_theme_file="$1"
    local target_theme_file="$2"

    # Load complete theme and target theme into variables
    complete_theme=$(jq '.' "$complete_theme_file")
    target_theme=$(jq '.' "$target_theme_file")

    # Create associative arrays to map colors to properties for fast lookup
    declare -A color_to_props
    declare -A prop_to_color

    # Populate color_to_props and prop_to_color arrays from complete theme
    while IFS= read -r line; do
        key=$(echo "$line" | awk '{print $1}')
        value=$(echo "$line" | awk '{print $2}')
        color_to_props["$value"]+="$key "
        prop_to_color["$key"]="$value"
    done < <(echo "$complete_theme" | jq -r 'to_entries[] | "\(.key) \(.value)"')

    # Generate filled theme by iterating over complete theme keys
    filled_theme="$target_theme"
    for key in "${!prop_to_color[@]}"; do
        if ! echo "$target_theme" | jq -e ".\"$key\"" &>/dev/null; then
            # Find corresponding color if missing in target theme
            value="${prop_to_color[$key]}"
            corresponding_color=""

            # Check if other properties with the same color exist in the target theme
            for prop in ${color_to_props["$value"]}; do
                if echo "$target_theme" | jq -e ".\"$prop\"" &>/dev/null; then
                    corresponding_color=$(echo "$target_theme" | jq -r ".\"$prop\"")
                    break
                fi
            done

            # Add missing property with the corresponding color
            if [ -n "$corresponding_color" ]; then
                filled_theme=$(echo "$filled_theme" | jq --arg key "$key" --arg value "$corresponding_color" '.[$key] = $value')
                echo "Added missing property: $key with value: $corresponding_color to $target_theme_file"
            else
                # Default action if no corresponding color is found
                echo "No corresponding color found for $key; using value from complete theme."
                filled_theme=$(echo "$filled_theme" | jq --arg key "$key" --arg value "$value" '.[$key] = $value')
            fi
        fi
    done

    # Write the filled theme back to the target file
    echo "$filled_theme" >"$target_theme_file"
    echo "Filled missing values in $target_theme_file"
}

# Process all theme files in the directory
for file in "$THEMES_DIR"/*.json; do
    filename=$(basename "$file")

    # Skip the complete theme files
    if [[ "$filename" == "$COMPLETE_THEME_FILE" ]] || [[ "$filename" == "$COMPLETE_SPLIT_THEME_FILE" ]]; then
        continue
    fi

    # Determine whether to use split or non-split complete theme
    if [[ "$filename" == *"_split"* ]]; then
        fill_missing_values "$THEMES_DIR/$COMPLETE_SPLIT_THEME_FILE" "$file"
    else
        fill_missing_values "$THEMES_DIR/$COMPLETE_THEME_FILE" "$file"
    fi
done
